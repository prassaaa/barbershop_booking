import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:dartz/dartz.dart';
import '../../../../core/errors/failures.dart';
import '../../../../shared/models/booking_model.dart';
import '../../../../shared/models/service_model.dart';
import '../../../../shared/models/barber_model.dart';
import '../../domain/usecases/booking_usecases.dart';
import 'booking_providers.dart';

// Booking Flow State
class BookingFlowState {
  final ServiceModel? selectedService;
  final BarberModel? selectedBarber;
  final DateTime? selectedDate;
  final String? selectedTimeSlot;
  final String? notes;
  final bool isLoading;
  final String? error;
  final List<String> availableTimeSlots;

  const BookingFlowState({
    this.selectedService,
    this.selectedBarber,
    this.selectedDate,
    this.selectedTimeSlot,
    this.notes,
    this.isLoading = false,
    this.error,
    this.availableTimeSlots = const [],
  });

  BookingFlowState copyWith({
    ServiceModel? selectedService,
    BarberModel? selectedBarber,
    DateTime? selectedDate,
    String? selectedTimeSlot,
    String? notes,
    bool? isLoading,
    String? error,
    List<String>? availableTimeSlots,
  }) {
    return BookingFlowState(
      selectedService: selectedService ?? this.selectedService,
      selectedBarber: selectedBarber ?? this.selectedBarber,
      selectedDate: selectedDate ?? this.selectedDate,
      selectedTimeSlot: selectedTimeSlot ?? this.selectedTimeSlot,
      notes: notes ?? this.notes,
      isLoading: isLoading ?? this.isLoading,
      error: error,
      availableTimeSlots: availableTimeSlots ?? this.availableTimeSlots,
    );
  }

  bool get canProceedToBarberSelection => selectedService != null;
  bool get canProceedToDateSelection => selectedService != null && selectedBarber != null;
  bool get canProceedToTimeSelection => selectedService != null && selectedBarber != null && selectedDate != null;
  bool get canCreateBooking => selectedService != null && 
                              selectedBarber != null && 
                              selectedDate != null && 
                              selectedTimeSlot != null;
}

// Booking Flow Notifier
class BookingFlowNotifier extends StateNotifier<BookingFlowState> {
  final Ref ref;

  BookingFlowNotifier(this.ref) : super(const BookingFlowState());

  void selectService(ServiceModel service) {
    state = state.copyWith(
      selectedService: service,
      selectedBarber: null, // Reset barber when service changes
      selectedDate: null,   // Reset date when service changes
      selectedTimeSlot: null, // Reset time slot when service changes
      availableTimeSlots: [],
    );
  }

  void selectBarber(BarberModel barber) {
    state = state.copyWith(
      selectedBarber: barber,
      selectedDate: null,   // Reset date when barber changes
      selectedTimeSlot: null, // Reset time slot when barber changes
      availableTimeSlots: [],
    );
  }

  void selectDate(DateTime date) {
    state = state.copyWith(
      selectedDate: date,
      selectedTimeSlot: null, // Reset time slot when date changes
      availableTimeSlots: [],
    );
    
    // Load available time slots for the selected date
    if (state.selectedBarber != null && state.selectedService != null) {
      _loadAvailableTimeSlots();
    }
  }

  void selectTimeSlot(String timeSlot) {
    state = state.copyWith(selectedTimeSlot: timeSlot);
  }

  void setNotes(String notes) {
    state = state.copyWith(notes: notes);
  }

  Future<void> _loadAvailableTimeSlots() async {
    if (state.selectedBarber == null || 
        state.selectedDate == null || 
        state.selectedService == null) {
      return;
    }

    state = state.copyWith(isLoading: true, error: null);

    final usecase = ref.read(getAvailableTimeSlotsProvider);
    final result = await usecase(TimeSlotParams(
      barberId: state.selectedBarber!.id,
      date: state.selectedDate!,
      serviceDuration: state.selectedService!.durationMinutes,
    ));

    result.fold(
      (failure) {
        state = state.copyWith(
          isLoading: false,
          error: failure.message,
        );
      },
      (timeSlots) {
        state = state.copyWith(
          isLoading: false,
          availableTimeSlots: timeSlots,
          error: null,
        );
      },
    );
  }
  Future<Either<Failure, BookingModel>> createBooking(String customerId) async {
    if (!state.canCreateBooking) {
      return const Left(ServerFailure('Incomplete booking information'));
    }

    state = state.copyWith(isLoading: true, error: null);

    final booking = BookingModel(
      id: '', // Will be generated by Firestore
      customerId: customerId,
      barberId: state.selectedBarber!.id,
      serviceId: state.selectedService!.id,
      bookingDate: state.selectedDate!,
      timeSlot: state.selectedTimeSlot!,
      status: 'waiting',
      totalPrice: state.selectedService!.price,
      notes: state.notes,
      cancelReason: null,
      createdAt: DateTime.now(),
      updatedAt: DateTime.now(),
    );

    final usecase = ref.read(createBookingProvider);
    final result = await usecase(CreateBookingParams(booking: booking));

    result.fold(
      (failure) {
        state = state.copyWith(
          isLoading: false,
          error: failure.message,
        );
      },
      (createdBooking) {
        state = state.copyWith(isLoading: false, error: null);
        // Reset the booking flow after successful creation
        resetBookingFlow();
      },
    );

    return result;
  }

  void resetBookingFlow() {
    state = const BookingFlowState();
  }

  void clearError() {
    state = state.copyWith(error: null);
  }
}

// Provider
final bookingFlowProvider = StateNotifierProvider<BookingFlowNotifier, BookingFlowState>((ref) {
  return BookingFlowNotifier(ref);
});

// Customer Bookings Provider
final customerBookingsProvider = FutureProvider.family<List<BookingModel>, String>((ref, customerId) async {
  final usecase = ref.read(getCustomerBookingsProvider);
  final result = await usecase(customerId);
  return result.fold(
    (failure) => throw Exception(failure.message),
    (bookings) => bookings,
  );
});

// Barbers by Service Provider
final barbersByServiceProvider = FutureProvider.family<List<BarberModel>, String>((ref, serviceId) async {
  final usecase = ref.read(getBarbersByServiceProvider);
  final result = await usecase(serviceId);
  return result.fold(
    (failure) => throw Exception(failure.message),
    (barbers) => barbers,
  );
});